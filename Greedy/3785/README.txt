================================================================================
【題目解析】貪婪算法結合分類討論 (Greedy + Case Study)
================================================================================

這是一道 Hard 難度中非常經典且有趣的題目。它不需要最大流等複雜圖論算法，
而是考驗對「錯排問題」變形的觀察力與邏輯推理。

--------------------------------------------------------------------------------
一、解題思路核心
--------------------------------------------------------------------------------

我們將所有的索引 (Index) 分為兩類：

  [1] 衝突區 (Conflict): 
      nums[i] == forbidden[i] 的位置。
      -> 這些位置必須被交換。

  [2] 安全區 (Safe): 
      nums[i] != forbidden[i] 的位置。

目標是消除所有的衝突。消除方式有兩種：

  A. 內部交換 (Internal Swap):
     找兩個衝突區的索引 i 和 j 交換。
     -> 運氣好可以一次解決 2 個衝突（效率最高）。

  B. 外部交換 (External Swap):
     拿一個衝突區的值，跟安全區的值交換。
     -> 通常一次只能解決 1 個衝突。

>> 核心策略：為了最小化交換次數，應盡可能多做「內部交換」。

--------------------------------------------------------------------------------
二、算法步驟詳解
--------------------------------------------------------------------------------

【步驟 1】預處理與可行性檢查 (Feasibility Check)

   基於「鴿籠原理 (Pigeonhole Principle)」，如果某個數字 V 的總數量，
   超過了它「允許存在的位置數量」，則不可能成功。

   * 定義：
     - Count(V):   V 在 nums 出現的總次數
     - Blocked(V): V 在 forbidden 出現的總次數
     - Allowed(V): n - Blocked(V)

   * 檢查條件：
     若對於任何 V，有 Count(V) > Allowed(V)，直接返回 -1。


【步驟 2】分析衝突區 (Analyze Conflicts)

   計算所有衝突的索引數量 S，並找出衝突區中的「眾數」。

   * 變數定義：
     - S:     總衝突數 (Total Conflicts)
     - max_f: 衝突區中出現頻率最高的數字之次數
     - X:     那個出現最多次的數字


【步驟 3】計算最小交換次數 (核心數學推導)

   這裡分為兩種情況討論：

   [情況 A] 沒有「絕對多數」的衝突值
   ------------------------------------------
   * 判斷式: 2 * max_f <= S
   *含義:
    衝突區的數字分佈比較均勻。我們可以把大部分衝突兩兩配對交換。
    例如衝突值 [1, 1, 2, 3]，可交換 (1, 2) 和 (1, 3)。
   * 公式: (S + 1) / 2  (整數除法)

   [情況 B] 有「絕對多數」的衝突值
   ------------------------------------------
   * 判斷式: 2 * max_f > S
   * 含義:
     某個數字 X 實在太多了。即使把所有「非 X」的衝突值都拿來跟 X 交換，
     還是會剩下一些 X 無法在衝突區內部解決，必須去跟「安全區」借位交換。
   * 公式: max_f

     (解釋：其實是 (S - max_f) 次內部交換 + (2 * max_f - S) 次外部交換，
      加起來剛好等於 max_f)

--------------------------------------------------------------------------------
三、C++ 程式碼參考
--------------------------------------------------------------------------------

#include <vector>
#include <map>
#include <algorithm>
#include <iostream>

using namespace std;

class Solution {
public:
    int minSwaps(vector<int>& nums, vector<int>& forbidden) {
        int n = nums.size();
        map<int, int> total_count;
        map<int, int> forbidden_count;
        
        // ---------------------------------------------------
        // 1. 統計頻率與可行性檢查
        // ---------------------------------------------------
        for (int x : nums) total_count[x]++;
        for (int x : forbidden) forbidden_count[x]++;
        
        for (auto const& [val, count] : total_count) {
            // 如果某個數字的總數 > (總長度 - 該數字被禁止的位置數)
            // 代表坑位不夠蘿蔔放，直接無解
            if (count > n - forbidden_count[val]) {
                return -1;
            }
        }
        
        // ---------------------------------------------------
        // 2. 分析衝突區
        // ---------------------------------------------------
        long long S = 0; // 總衝突數
        map<int, int> conflict_freq;
        int max_f = 0;   // 衝突區中出現最多次的頻率
        
        for (int i = 0; i < n; i++) {
            if (nums[i] == forbidden[i]) {
                S++;
                conflict_freq[nums[i]]++;
                max_f = max(max_f, conflict_freq[nums[i]]);
            }
        }
        
        // 如果沒有衝突，不用交換
        if (S == 0) return 0;
        
        // ---------------------------------------------------
        // 3. 根據數學推導回傳結果
        // ---------------------------------------------------
        
        // 情況 A: 衝突值分佈均勻，可以主要靠內部互換解決
        if (2 * max_f <= S) {
            return (S + 1) / 2;
        } 
        
        // 情況 B: 某個衝突值 X 太多了，剩下的 X 必須跟外部安全區換
        // 數學推導後，總次數就是 max_f
        else {
            return max_f;
        }
    }
};

--------------------------------------------------------------------------------
四、複雜度分析
--------------------------------------------------------------------------------

[ 時間複雜度 ]: O(N)
雖然用了 map (或是 unordered_map)，但我們只遍歷了數組幾次。
如果是 std::map 則是 O(N log N)，考慮到題目 N=10^5，這絕對能過。

[ 空間複雜度 ]: O(N)
用於儲存頻率表 (Frequency Maps)。

================================================================================